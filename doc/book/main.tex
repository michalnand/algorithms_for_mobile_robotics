% universal settings
\documentclass[12pt,twoside,onecolumn,openany,extrafontsizes,dvipsnames]{memoir}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}

\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{color}
\usepackage{listings}
\usepackage{xcolor}



\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{white}{rgb}{0.9,0.9,0.9}
\definecolor{dark_gray}{rgb}{0.2,0.2,0.2}

\lstdefinestyle{python_style}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\tiny,
    language=Python,
    numbers=left,
    stepnumber=1,
    numbersep=10pt,
    tabsize=4,
    showspaces=false,
    showstringspaces=false
}

\lstdefinestyle{cpp_style}{
    language=C++,
    basicstyle=\ttfamily\tiny,
    backgroundcolor=\color{backcolour}, 
    keywordstyle=\color{magenta}\ttfamily\tiny,
    stringstyle=\color{codepurple}\ttfamily\tiny,
    commentstyle=\color{codegreen}\ttfamily\tiny,
    numbersep=10pt,
    tabsize=4,
}


\lstdefinestyle{terminal_style}{
    basicstyle=\ttfamily\tiny\color{white},
    backgroundcolor=\color{dark_gray}, 
    numbersep=10pt,
    tabsize=4,
}

\lstset{style=python_style}



%%%%%%%%%% BOOK INFORMATION %%%%%%%%%%
\title{Hands on Algorithms for robotics}
\author{Michal Chovanec, PhD.}
\date{\today}


\begin{document}
\maketitle


\chapter{Hardware description}
%\section{block diagram}


    \newpage
    \begin{figure}[h]
        \begin{subfigure}{.5\textwidth}
            \centering
            \includegraphics[scale=0.35]{../images/robot/board_dims_a.png}
            \caption{mechanical dimensions}
            \label{fig:mechanical_dimensions}
        \end{subfigure}%
        \begin{subfigure}{.5\textwidth}
            \centering
            \includegraphics[scale=0.35]{../images/robot/board_all.png}
            \caption{overall PCB layout}
            \label{fig:overall_PCB_layout}
        \end{subfigure}


        \caption{Robot PCB}
    \end{figure}

    \begin{figure}[!b]
        \centering
        \includegraphics[scale=0.05]{../images/robot/robot_01.jpg}
        \caption{Robot photo}
        \label{fig:robot_photo}
    \end{figure}

    \newpage
    \begin{figure}[h]
        \centering
        \includegraphics[scale=0.8]{../diagrams/sw/sw-block_dc.png}
        \caption{block diagram of DC motor version}
    \end{figure}

    \newpage
    \begin{figure}[h]
        \centering
        \includegraphics[scale=0.28]{../images/robot/schem_gs.png}
        \caption{schematic diagram of DC motor version}
    \end{figure}

    \newpage

        \begin{table}[h!]
            \centering
                \begin{tabular}{||c c c c c||} 
                \hline
                pin number & pin name & function & peripheral & AF number \\
                \hline\hline
                    14 & PA0 & line sensor ADC0, right & ADC1 & analog in \\ 
                    15 & PA1 & line sensor ADC1 & ADC1 & analog in \\ 
                    16 & PA2 & line sensor ADC2 & ADC1 & analog in \\ 
                    17 & PA3 & line sensor ADC3 & ADC1 & analog in \\ 
                    20 & PA4 & line sensor ADC4 & ADC1 & analog in \\ 
                    21 & PA5 & line sensor ADC5 & ADC1 & analog in \\ 
                    22 & PA6 & line sensor ADC6 & ADC1 & analog in \\ 
                    23 & PA7 & line sensor ADC7, left & ADC1 & analog in \\ 
                    & & & & \\
                    25 & PB0 & IR sensor ADC8, front left  & ADC1 & analog in \\ 
                    26 & PB1 & IR sensor ADC9, left & ADC1 & analog in \\ 
                    8 & PC0 & IR sensor ADC10, right & ADC1 & analog in \\ 
                    9 & PC1 & IR sensor ADC11, front right & ADC1 & analog in \\ 
                    & & & & \\
                    51 & PC10 & encoder left A  & GPIOC &  \\ 
                    52 & PC11 & encoder left B  & GPIOC &  \\ 
                    53 & PC12 & encoder right A  & GPIOC &  \\ 
                    57 & PB5  & encoder right B  & GPIOB &  \\ 
                    & & & & \\
                    37 & PC6 & PWM left A   & TIM3\_CH1 & AF2 \\     
                    38 & PC7 & PWM left B   & TIM3\_CH2 & AF2 \\ 
                    58 & PB6 & PWM right A  & TIM4\_CH1 & AF2 \\ 
                    59 & PB7 & PWM right B  & TIM4\_CH2 & AF2 \\ 
                    & & & & \\
                    10 & PC2 & IMU I2C, SDA & GPIOC &  \\ 
                    11 & PC3 & IMU I2C, SCL & GPIOC &  \\ 
                    & & & & \\
                    42 & PA9 & uart TX & UART1 & AF7 \\ 
                    43 & PA10 & uart RX & UART1 & AF7 \\ 
                    & & & & \\
                    27 & PB2 & user LED & GPIOB &  \\ 
                    28 & PB10 & user Key & GPIOB &  \\ 
                    29 & PB11 & IR LED control & GPIOB &  \\ 
                    24 & PC4 & line LED control & GPIOC &  \\ 
                    & & & & \\
                    7 & NRST & reset &  &  \\ 
                    60 & BOOT0 & firmware bootloader control &  &  \\ 
                \hline
                \end{tabular}
            \caption{pin mapping and function}
            \label{table:1}
        \end{table}

\newpage
\chapter{System identification}

    \section{State space models}

        System state is column vector, with $N$ rows
        \begin{align}
            x(n) &= \begin{bmatrix} x_{0}(n) \\ x_{1}(n) \\ ... \\ x_{N-1}(n) \end{bmatrix}
        \end{align}

        For single output system this vector contains single value, e.g. the motor velocity $\omega(n)$
        \begin{align}
            x(n) &= \begin{bmatrix} \omega(n) \end{bmatrix}
        \end{align}


        If we have 2nd order system, e.g. servo with inertia, the state will contain two 
        elements : 
        \begin{itemize}
            \item motor shaft velocity $\omega(n)$, measured in $rad/s$
            \item motor shaft angle $\theta(n)$, measured in $rad$
        \end{itemize}

        \begin{align}
            x(n) &= \begin{bmatrix} \omega(n) \\ \theta(n) \end{bmatrix}
        \end{align}

        More accurate servo model observes also motor current $i(n)$, which gives us three element state vector
        \begin{align}
            x(n) &= \begin{bmatrix} i(n) \\ \omega(n) \\ \theta(n) \end{bmatrix}
        \end{align}

        Robot moving in 2D plane have usualy state containing robot position $x'$, $y'$, and robot orientation $\theta$

        \begin{align}
            x(n) &= \begin{bmatrix} x'(n) \\ y'(n) \\ \theta(n) \end{bmatrix}
        \end{align}

        The number of rows in state vector $x(n)$ is called \textbf{system order}.

        The dynamical system is controlled with $M$ inputs, stacked in column input vector $u(n)$
        \begin{align}
            u(n) &= \begin{bmatrix} u_{0}(n) \\ u_{1}(n) \\ ... \\ u_{M-1}(n) \end{bmatrix}
        \end{align}

        The system with single input, e.g. motor with current control, input vector contains single value 
        \begin{align}
            u(n) &= \begin{bmatrix} i(n) \end{bmatrix}
        \end{align}

        Differential drive robot where are controlled two independent motors have two inputs 
        \begin{align}
            u(n) &= \begin{bmatrix} i_{left}(n) \\ i_{right}(n) \end{bmatrix}
        \end{align}

        Relation between control input $u(n)$, current state $x(n)$ and next state $x(n+1)$ can be 
        modeled using \textbf{linear state space model}
        
        \begin{align}
            x(n+1) &= Ax(n) + Bu(n)
        \end{align}

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.6]{../diagrams/control_generic/control_generic-discrete_dynamics.png}
            \caption{State space model matrices shapes}
            \label{fig:state_space_model_matrices_shapes}
        \end{figure}
        
        This model can capture dynamics of any linear system. Sometimes the state $x(n)$ can't be 
        meassured directly, and we observe only system output $y(n) = Cx(n)$. Where matrix $C$ have k-rows and n-columns.
        In our case we consider we have access to full state $x(n)$.
        There is of course the continuous form of state space model 

        \begin{align}
            \frac{dx}{dt} &= A^cx(t) + B^cu(t)
        \end{align}

        note : the martices $A^c$ and $B^c$ differs from discrete system matrices $A$ and $B$.
        They are related with bilinear transform as 
        
        \begin{align}
            S_a &= (I - \frac{\Delta T}{2}A^c)^{-1} \\
            S_b &= I + \frac{\Delta T}{2}A^c \\
            A &=  S_aS_b \\
            B &= S_a B^c \Delta T 
        \end{align}

        where $\Delta T$ is sampling period. This is mostly used discretisation, 
        from continuous (e.g. physical) model into discrete form.
        Following pythoncode convert continous system into discrete system. 
        If system contains output matrix $C$ discretisation doesn't effects its values.
       
        \begin{lstlisting}[style=python_style]
def c2d(a, b, c, dt):
    i = numpy.eye(a.shape[0])
    
    tmp_a = numpy.linalg.inv(i - (0.5*dt)*a)
    tmp_b = i + (0.5*dt)*a

    a_disc  = tmp_a@tmp_b
    b_disc  = (tmp_a*dt)@b

    return a_disc, b_disc, c
        \end{lstlisting}
       
        Process of system identification is finding matrices $A$, $B$ (and $C$). From this model 
        can be sythetised controller, or system able to plan multiple steps ahead.

    \section{First order identification}   
        Goal is to find parameters of DC motor. Motor velocity model, can be approximated as 1st linear order system. 
        Real system is of course non-linear. The photo of example system is on fig \ref{fig:wheel_drive_detail}.
        Control loop hardware consists of motor driver (H-driver, DRV8212), motor (Pololu HP 1:30 gear), and quadrature magnetic encoder (2x DRV5013),
        fig \ref{fig:motor_identification_process}

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.8]{../diagrams/control_generic/control_generic-motor_control_photo.png}
            \caption{Wheel drive hardware detail}
            \label{fig:wheel_drive_detail}
        \end{figure}

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.6]{../diagrams/identification/identification.png}
            \caption{Motor identification process}
            \label{fig:motor_identification_process}
        \end{figure}

        Input signal $u(n)$ can be generated arbitrarily. Mostly used is square wave, to capture
        high frequency dynamics. Algorithm is from observed motor velocity $x(n)$ and given input $u(n)$
        estimating model parameters.

        Before real motor testing, we focus on simulation example.
        Our simulated motor will have following parameters

        \begin{itemize}
            \item sampling frequency 4kHz, $\Delta T = 1/4000$
            \item maximum control input $u_{max} = 2$
            \item motor constant $k = 17$
            \item motor time constat $\tau = 29$ milliseconds
        \end{itemize}

        Motor state is single variable, angular velocity $\omega(t)$. Model have two parameters $\alpha$, $\beta$. 
        First order continuos model becomes

        \begin{align}
            \frac{d\omega(t)}{dt} &= \alpha \omega(t) + \beta u(t) \label{eq:first_order_system_a} \\
            \alpha &= -\frac{1}{\tau}  \label{eq:first_order_system_b} \\
            \beta &= \frac{k}{\tau}  \label{eq:first_order_system_c}
        \end{align}

        with given parameters $k$ and $\tau$ becomes $\alpha = -34.48$ and $\beta = 586.2$.

        Unit step response is obtained by setting $u(n) = 1$, and solving using any differential 
        equation solver. The simplest is Euler method, which works well for small $dt$ and low order 
        systems. Much accurate is commonly used Runge-Kutta 4 method.

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.6]{../images/motor_control/motor_step_response.png}
            \caption{Motor step response}
            \label{fig:motor_step_response}
        \end{figure}

        Our goal is to generate input $u(t)$ and by observing system output $x(t)$ estimate parameters
        $k$ and $\tau$.

        We start with simplest identification method, which works only for 1st order non-oscilating systems.
        Method have two main steps
        \begin{enumerate}
            \item steady state value estimation
            \item time constant estimation
        \end{enumerate}

        \subsection{Steady state estimation}

            We drive motor on different input levels, e.g. ranging from 10\% ... 100\%. Observing steady 
            state velocity the motor constant $k$ can be estimated.

            \begin{figure}[!htb]
                \centering
                \includegraphics[scale=0.6]{../images/motor_control/motor_constant_estimation.png}
                \caption{Motor constant estimation}
                \label{fig:motor_constant_estimation}
            \end{figure}

            Algorithm for estimating motor constant :

            \begin{enumerate}
                \item choose constant motor input $u \in (0, u_{max} \rangle$
                \item run motor, and wait for velocity steady state
                \item measure velocity  
                \item estimate $\hat{k} = x/u$
                \item repeats to estimate average $\hat{k}$
            \end{enumerate}

            In following code we choose 10 different input levels. After setting, we wait 500steps
            to steady state, then we measure output velocity. Finally, we average results.

            \begin{lstlisting}[style=python_style]
# input levels
u_values = u_max*numpy.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])

# reset dynamical system into zero state
ds.reset()

for j in range(len(u_values)):

    x_mean = []
    for i in range(1000):

        # convert scalar u to column vector
        u    = u_values[j]
        u    = numpy.array([[u]])
        
        # compute dynamical system one step
        x, _ = ds.forward_state(u)

        # after steady state, store x
        if i > 500:
            x_mean.append(x[0][0])

    x_mean = numpy.array(x_mean)
    x_mean = x_mean.mean()

    k_est = x_mean/u_values[j]

    print(u_values[j], k_est)

k_mean = k_est.mean()

# average k estimate
print("k_mean = ", k_mean)
            \end{lstlisting}

        In our example the resulted $\hat{k}$ is $16.995$, which very close to real value $17$.
        Accuracy depends on velocity estimation noise (encoder noise) and how many samples we average.
        
        \subsection{Time constant estimation}

            Second parameter is time constant $\tau$. Most textbooks uses measuring time at which system 
            reaches $63.2\%$ of $x_{max}$. Where $x_{max}$ is motor velocity on choosen $u$, a.k.a. steady 
            state velocity at $u$. This method suffers to noise, and precise timing. Here we presents 
            more accurate method, briging system into natural frequency resonance.
            Algorithm is as follow :
        
            \begin{enumerate}
                \item choose $u_{set}$, and set $u_{in} = u_{set}$
                \item repeat $n_{steps}$, each step duration is $\Delta T$
                    \begin{enumerate}
                        \item $if\ u_{in} > 0\ and\ x(n) > 0.632ku_{in}$ \\
                            increment $n_{HalfPeriods}$, and set $u_{in} = -u_{set}$
                        \item $else\ if\ u_{in} < 0\ and\ x(n) < 0.632ku_{in}$ \\
                            increment $n_{HalfPeriods}$, and set $u_{in} = u_{set}$
                    \end{enumerate}
            \end{enumerate}

            The time constant $\hat{\tau}$ can be now estimated by 

            \begin{align}   
                \hat{\tau} = \frac{2}{\pi}\frac{n_{steps}}{n_{HalfPeriods}}{\Delta T}
            \end{align}

            Where $\Delta T$ is sampling period, ratio ${n_{steps}} : {n_{HalfPeriods}}$ is
            estimating system frequency. In core, this method is nothing more than  period 
            duration estimation. The resulted time plot is on fig.  \ref{fig:motor_time_constant_estimation}.
            Result for our simulated motor is $\hat{\tau} = 27.44[ms]$, which is good estimation of real value $29 [ms]$.

            \begin{figure}[!htb]
                \centering
                \includegraphics[scale=0.6]{../images/motor_control/motor_time_constant_estimation.png}
                \caption{Motor time constant estimation}
                \label{fig:motor_time_constant_estimation}
            \end{figure}
            
            Using equations \ref{eq:first_order_system_b} and \ref{eq:first_order_system_c} we can estimate $\hat{\alpha}$ and $\hat{\beta}$ as
            $\hat{\alpha} = -36.443$ and $\hat{\beta} = 619.372$

          

        \subsection{Real motor identification}
            For implementation in real system, the code must runs in real time. With relative high 
            sampling frequency 4kHz, the code is written in c++. Interface is universal, with few key functions.

            \begin{itemize}
                \item timer.delay\_ms(unsigned int time) - waits given milliseconds
                \item float x = motor\_control.get\_right\_velocity() - return meassured wheel velocity
                \item motor\_control.set\_right\_torque(float x) - sets the PWM value, depends on sign the rotation direction can be controlled
            \end{itemize}

            This functions needs to be customised for user application.

            \newpage
            First we estimate motor constant $k$ :
            
            \begin{lstlisting}[style=cpp_style]
//1, estimate motor constant k, on different input values
uint32_t n_steps = 500;

float u_values[10] = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};

float k_mean     = 0.0;
float x_var_mean = 0.0;

for (unsigned int j = 0; j < 10; j++)
{
    //run motor with desired input and wait for steady state
    float u_in = u_values[j];

    motor_control.set_right_torque(u_in*MOTOR_CONTROL_MAX_TORQUE); 
    timer.delay_ms(500);    

    //estimate average velocity
    float x_mean = 0.0;
    for (unsigned int i = 0; i < n_steps; i++)
    {
        float x = motor_control.get_right_velocity();
        x_mean+= x;
        timer.delay_ms(1); 
    }
    x_mean = x_mean/n_steps;    

    //estimate average variance - encoder noise
    float x_var = 0.0;
    for (unsigned int i = 0; i < n_steps; i++)
    {
        float x = motor_control.get_right_velocity();
        x_var+= (x - x_mean)*(x - x_mean);
        timer.delay_ms(1);
    }
    x_var = x_var/n_steps;  

    float k = x_mean/u_in;
    k_mean+= x_mean/u_in;   
    x_var_mean+= x_var;

    terminal << "u_in   = " << u_in << "\n";
    terminal << "k      = " << k << "\n";
    terminal << "x_mean = " << x_mean << "\n";
    terminal << "x_var  = " << x_var << "\n";
    terminal << "\n\n";
}   

//print summary results
k_mean     = k_mean/10.0;
x_var_mean = x_var_mean/10.0;

terminal << "k          = " << k_mean << "\n";
terminal << "x_var_mean = " << x_var_mean << "\n";
        \end{lstlisting}
    
        \newpage
        Second we estimate motor time constant $\tau$ :
        \begin{lstlisting}[style=cpp_style]
//2, estimate time constant by oscilating motor
float u_in = 0.25;
uint32_t periods = 0; 

n_steps = 2000;

for (unsigned int i = 0; i < n_steps; i++)
{
    motor_control.set_right_torque(u_in*MOTOR_CONTROL_MAX_TORQUE);
    float x = motor_control.get_right_velocity()*60.0/(2.0*PI);

    if (u_in > 0.0) 
    {
        if (x > 0.632*k_mean*u_in)
        {
            u_in = -u_in;
            periods++;
        }
    }
    else
    {
        if (x < 0.632*k_mean*u_in)
        {
            u_in = -u_in;
            periods++;  
        }
    }

    timer.delay_ms(1);
}

float t_period = (2*n_steps/periods)/PI;
terminal << "periods = " << periods << "\n";
terminal << "tau     = " << t_period << "[ms]\n";
terminal << "\n\n";

        \end{lstlisting}

        \newpage
        Average motor constant is $k = 80.056$, and time constant is $\tau = 9.230[ms]$.
        Terminal output :
        \begin{lstlisting}[style=terminal_style]
...

u_in   =  0.800
k      =  87.194
x_mean =  69.755
x_var  =  19.236


u_in   =  0.900
k      =  86.440
x_mean =  77.796
x_var  =  18.124


u_in   =  1.000
k      =  85.750
x_mean =  85.750
x_var  =  7.554


k          =  80.056
x_var_mean =  170.903


periods = 136
tau     =  9.230[ms]
        \end{lstlisting}

        

\newpage
\chapter{Motion control}

    \section{Motor velocity controller}

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.6]{../diagrams/control_generic/control_generic-motor_control.png}
            \caption{Velocity control overview}
            \label{fig:velocity_control_overview}
        \end{figure}


        \newpage
        \section{PID control}

            \begin{figure}[!htb]
                \centering
                \includegraphics[scale=0.8]{../diagrams/control_generic/control_generic-pid.png}
                \caption{Textbook continuous PID controller}
                \label{fig:textbook_continuous_pid_controller}
            \end{figure}

            \begin{figure}[!htb]
                \centering
                \includegraphics[scale=0.8]{../diagrams/control_generic/control_generic-pid_discrete.png}
                \caption{Discrete PID controller }
                \label{fig:discrete_pid_controller}
            \end{figure}

            
            \begin{align}
                k_0 &= K_p + K_i\Delta T + \frac{K_d}{\Delta T} \\
                k_1 &= -K_p - 2\frac{K_d}{\Delta T} \\
                k_2 &= \frac{K_d}{\Delta T}
            \end{align}

                \newpage
                \subsection{PID control - P only controller}

                    \begin{itemize}
                        \item  target value : \textcolor{red}{\textbf { 1000rpm}}
                        \item  P-only control causes \textcolor{red}{\textbf {steady state error}}
                    \end{itemize}
                
                    \begin{align}
                        u(n+1) &= u(n-1) + k_pe(n) - k_pe(n-1) \\
                        k_p    &= 0.01
                    \end{align}

                    \begin{figure}[!htb]
                        \centering
                        \includegraphics[scale=0.8]{../images/motor_control/pid_p_control.png}
                        \caption{P-only controller}
                        \label{fig:p_controller}
                    \end{figure}

                \newpage
                \subsection{PID control - PI}
                    
                    too high I term 

                    \begin{itemize}
                        \item  target value : \textcolor{red}{\textbf {1000rpm}}
                        \item  PI control \textcolor{red}{\textbf {removes steady state error}}
                        \item  too high I term causes \textcolor{red}{\textbf {oscilations and overshot}}
                    \end{itemize}
                
                
                    \begin{align}
                        u(n+1) &= u(n-1) + (k_p + k_i\Delta T) e(n) - k_pe(n-1) \\
                        k_p    &= 0.01 \\
                        k_i\Delta T    &= 0.005
                    \end{align}
                    
                    
                    \begin{figure}[!htb]
                        \centering
                        \includegraphics[scale=0.8]{../images/motor_control/pid_pi_control_0.png}
                        \caption{PI controller}
                        \label{fig:pi_controller}
                    \end{figure}

                    correct I term

                    \begin{itemize}
                        \item  target value : \textcolor{red}{\textbf {1000rpm}}
                        \item  correct tunned PI controller for 1st order system
                        \item  \textcolor{red}{\textbf {no overshot, no steady state error}}
                    \end{itemize}
                    
                    \begin{align}
                        u(n+1) &= u(n-1) + (k_p + k_i\Delta T) e(n) - k_pe(n-1) \\
                        k_p    &= 0.01 \\
                        k_i\Delta T    &= 0.0002
                    \end{align}

                    \begin{figure}[!htb]
                        \centering
                        \includegraphics[scale=0.8]{../images/motor_control/pid_pi_control_1.png}
                        \caption{PI controller with correct parameters}
                        \label{fig:pi_controller_correct}
                    \end{figure}
                    
                \newpage
                \subsection{Complete discrete PID algorithm}  
        
                    \begin{enumerate}
                    \item  calculate u-change candidate :
                        $$\Delta \hat{u}(n) = k_0e(n) + k_1e(n) + k_2e(n)$$
                    
                    \item clip maximum allowed u-change, to avoid u-kick :
                        $$\Delta u(n) = clip(\Delta \hat{u}(n), -du_{min}, du_{max})$$
                
                    \item clip maximum allowed u value, to avoid saturation / windup :
                        $$u(n) = clip(u(n-1) + \Delta u(n), -u_{min}, u_{max})$$
                    \end{enumerate}

                    Full Python code example for discrete PID controller :
                    \begin{lstlisting}[style=python_style]
class PID:

def __init__(self, kp, ki, kd, antiwindup = 10**10, du_max=10**10):
    self.k0 = kp + ki + kd
    self.k1 = -kp -2.0*kd
    self.k2 = kd

    self.e0 = 0.0
    self.e1 = 0.0
    self.e2 = 0.0
    
    self.antiwindup = antiwindup
    self.du_max     = du_max

def forward(self, xr, x, u_prev):
    # error compute
    self.e2 = self.e1
    self.e1 = self.e0
    self.e0 = xr - x

    # u-change computing
    du = self.k0*self.e0 + self.k1*self.e1 + self.k2*self.e2

    # kick clipping, maximum output value change limitation
    du  = numpy.clip(du, -self.du_max , self.du_max)

    # antiwindup, maximum output value limitation
    u   = numpy.clip(u_prev + du,  -self.antiwindup, self.antiwindup)

    return u
                    \end{lstlisting}





    \newpage
    \section{Optimal control}
       
        Optimal control is solution of following optimisation problem

        \begin{align}
            \min_{x(.), u(.)} \sum_{n=0}^\infty x^T(n)Qx(n) + u^T(n)Ru(n) \\
            s.t.\ x(n+1) = Ax(n) + Bu(n)
        \end{align}

        the cost function is quadratic
        \begin{align}
            J &= \sum_{n=0}^\infty x^T(n)Qx(n) + u^T(n)Ru(n)
        \end{align}

        where $Q$ and $R$ are positive semidefinite square matrices, with shapes $N \times N$ and $M \times M$ respectively.
        The system order is $N$ and system have $M$ inputs.
        Matrix $Q$ penalises magnitude of $x(n)$ elements, matrix $R$ penalises control input $u(n)$ elements.
        Solution is obtained by solving algebraic Riccati equation, and results in feedback gain $u(n) = -Kx(n)$.
        This controller is called \textbf{Linear Quadratic Regulator - LQR}.
        This matrix can fully manipulate with system poles and guarantee system stability.
        However, given structure have steady state error - brings system always into zero state.
        To eliminate this issue, we introduce integral action term by augmenting system matrices. 
        Resulted controller have two matrices : feedback gain $K$ and integral action gain $K_i$ matrix.
        The modified LQR controller have form on following fig \ref{fig:control_lqr_generic} 
        with equations \ref{eq:lqr_integral_action}.

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.8]{../diagrams/control_generic/control_generic-lqr_discrete.png}
            \caption{LQR controller with integral action}
            \label{fig:control_lqr_generic}
        \end{figure}

        \begin{align}
            u(n)&= -Kx(n) + K_ie_{int}(n) \label{eq:lqr_integral_action} \\
            e_{int}(n)& = e_{int}(n-1) + x_r(n) - x(n)
        \end{align}

        where : 
        \begin{itemize}
            \item $x(n)$ is observerd state, column vector, with shape $(N, 1)$
            \item $x_r(n)$ is required state, column vector, with shape $(N, 1)$
            \item $u(n)$ is controller output, column vector, with shape $(M, 1)$
            \item $K$ is feedback gain matrix, with shape $(M, N)$
            \item $K_i$ is integral gain matrix, with shape $(M, N)$ 
        \end{itemize}


        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.8]{../diagrams/control_generic/control_generic-lqr_detail.png}
            \caption{Matrices shapes in LQR controller}
            \label{fig:control_lqr_matrices_shape}
        \end{figure}
        
    \newpage
    \section{Model predictive control}

        Previous controllers were focused only on single step in required state $x_r(n)$.
        Model predictive control solves more generic problem, where required input 
        is not single a state $x_r(n)$ but whole sequence $X_r(n)$. 
        This is called trajectory tracking problem and $X_r(n)$ is required trajectory with length of $H$-steps.
        $H$ is called prediction horizon. Controller uses dynamics model of controlled system to predict
        future steps. The control sequence $u(n)$ is optimised the controlled system follows the required 
        trajectory $X_r(n)$.

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.5]{../diagrams/control/control-mpc_steps.png}
            \caption{Principle of model predictive control}
            \label{fig:mpc_steps}
        \end{figure}
        
        Model predictive control is solution of following optimisation problem

        \begin{align}
            \min_{x(.), \Delta u(.)} &\sum_{h=0}^H (x_r^T(h) - x^T(h))Q(x_r(h) - x(h)) + _\Delta u^T(h)R_\Delta u(h) \\
            s.t.\ x(n+1) &= Ax(n) + Bu(n) \\
            u(n) &= u(n-1) + _\Delta u(n)
        \end{align}

        where : 
        \begin{itemize}
          \item $H$ is prediction horizon steps
          \item $A$ is matrix, $n \times n$
          \item $B$ is matrix, $n \times m$
          \item $Q$ is matrix, $n \times n$
          \item $R$ is matrix, $m \times m$
          \item $_\Delta u$ is controller output
          \item $n$ is system orders, and $m$ system inputs count
        \end{itemize}

        Unwrap into form where only $x(n)$ and $u(n-1)$ are used to predict all other $x$
        \begin{align*}
            x(n+1)&= Ax(n) + Bu(n) \\
                &= Ax(n) + B(u(n-1) + _\Delta u(n)) \\
            x(n+2)&= Ax(n+1) + B(u(n) + _\Delta u(n+1)) \\
                &= A^2x(n) + (AB + B)u(n-1) + (AB+B)_\Delta u(n) + B_\Delta u(n) \\
            x(n+3)&= Ax(n+2) + B(u(n+1) + _\Delta u(n+2)) \\
                &= A^3x(n) + (A^2 + AB + B)u(n-1) \\
                & + (A^2B + AB + B)_\Delta u(n) \\
                & + (AB + B)_\Delta u(n+1) + B_\Delta u(n+2) \\
            ... 
        \end{align*}  


        Rewrite into matrix form
        \begin{align*}
            \begin{bmatrix}
            x(n+1) \\
            x(n+2) \\
            \dots \\
            x(n+H)
            \end{bmatrix} &= 
            \begin{bmatrix}
            A^1 \\
            A^2 \\
            \dots \\
            A^H
            \end{bmatrix} x(n) +
            \begin{bmatrix}
            B \\
            AB + B \\
            \dots \\
            \sum_{i=0}^{H-1} A^iB
            \end{bmatrix} u(n-1) + \\
            &+
            \begin{bmatrix}
            B  & 0 & \dots & 0 \\
            AB + B & B & \dots & 0 \\
            \dots & \dots & \dots & \dots \\
            \sum_{i=0}^{H-1}A^iB & \sum_{i=0}^{H-2}A^iB & \dots & B
            \end{bmatrix}
            \begin{bmatrix}
            _\Delta u(n) \\
            \dots \\
            _\Delta u(n + H - 1) \\
            \end{bmatrix} 
        \end{align*}

        in compact matrix form

        \begin{align*}
            \tilde{X} &= \Psi x(n) + \Omega u(n-1) + \Theta \tilde{_\Delta U}
        \end{align*}

        Explonation : 
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.8]{../diagrams/control/control-mpc_exp_1.png}
            \caption{Effect of current state $x(n)$ and input $u(n)$ to all output steps}
            \label{fig:mpc_exp_1}
        \end{figure}

        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.8]{../diagrams/control/control-mpc_exp_2.png}
            \caption{Effect of n-th input step $_\Delta u(n)$ on output}
            \label{fig:mpc_exp_2}
        \end{figure}


        Formulate quadratic loss (cost) function
        \begin{align*}
            J &= \tilde{_\Delta U}^T \tilde{R} \tilde{_\Delta U} 
                        + (\tilde{X_r} - \tilde{X})^T \tilde{Q} (\tilde{X_r} - \tilde{X})^T \\
        \end{align*}

        after substitution
        \begin{align*}
            S = \tilde{X_r} - \Psi\tilde{X} - \Omega u(n-1)
        \end{align*}

        we get
        \begin{align*}
            J &= \tilde{_\Delta U}^T \tilde{R} \tilde{_\Delta U} + (S -  \Theta \tilde{_\Delta U} )^T \tilde{Q} (S -  \Theta \tilde{_\Delta U} ) \\
                        &= \tilde{_\Delta U}^T \tilde{R} \tilde{_\Delta U} 
                        + S^T\tilde{Q}S - S^T \tilde{Q} \Theta \tilde{_\Delta U} 
                        - \tilde{_\Delta U}^T \Theta^T\tilde{Q}S + \tilde{_\Delta U}^T\Theta^T\tilde{Q}\Theta\tilde{_\Delta U}
        \end{align*}

        \newpage
        find derivative with respect to $\tilde{_\Delta U}$ 

        \begin{align*}  
            \frac{\partial J}{\partial {\tilde{_\Delta U}}} & : \\
            \frac{\partial {\tilde{_\Delta U}^T \tilde{R} \tilde{_\Delta U} } }{\partial {\tilde{_\Delta U}}} & = 2\tilde{R}\tilde{_\Delta U} \\
            \frac{\partial {S^T\tilde{Q}S}}{\partial {\tilde{_\Delta U}}} & = 0 \\
            \frac{\partial {- S^T \tilde{Q} \Theta \tilde{_\Delta U} }}{\partial {\tilde{_\Delta U}}} & = -\Theta^T\tilde{Q}S \\
            \frac{\partial {- \tilde{_\Delta U}^T \Theta^T\tilde{Q}S}}{\partial {\tilde{_\Delta U}}} & = -\Theta^T\tilde{Q}S \\
            \frac{\partial { \tilde{_\Delta U}^T\Theta^T\tilde{Q}\Theta\tilde{_\Delta U}}}{\partial {\tilde{_\Delta U}}} & = 2\Theta^T\tilde{Q}\Theta\tilde{_\Delta U}
        \end{align*}  


        put derivate equal to zero, and solve

        \begin{align*}
          \frac{\partial J}{\partial {\tilde{_\Delta U}}} & = 2 \tilde{R} \tilde{_\Delta U} - 2\Theta^T\tilde{Q}S + 2\Theta^T\tilde{Q}\Theta\tilde{_\Delta U} \\
          0 &= 2 \tilde{R} \tilde{_\Delta U} - 2\Theta^T\tilde{Q}S + 2\Theta^T\tilde{Q}\Theta\tilde{_\Delta U} \\
          (\tilde{R} + \Theta^T\tilde{Q}\Theta)\tilde{_\Delta U}  &= \Theta^T\tilde{Q}S 
        \end{align*}  
      
        and \textbf{obtain solution for unconstrained model predictive controll}
        \begin{align*}
          \tilde{_\Delta U} &= (\tilde{R} + \Theta^T\tilde{Q}\Theta)^{-1} \Theta^T\tilde{Q}S
        \end{align*} 

        \textbf{model predictive control - full algorithm} \\
        given matrices : $\tilde{Q}, \tilde{R}, \Theta, \Phi, \Omega$ \\
        initialization (precompute) :
        \begin{align*}
        \Xi &= (\tilde{R} + \Theta^T\tilde{Q}\Theta)^{-1} \Theta^T\tilde{Q} \\
        \end{align*}
        
        \textbf{in loop process controller step :}
        \begin{align*}
          E(n) &= X_r(n) - \Phi x(n) - \Omega u(n-1) \\
          _\Delta u(n) &= \Xi E(n) \\
          u(n) &= u(n-1) + _\Delta u(n)
        \end{align*}
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.8]{../diagrams/control/control-mpc.png}
            \caption{Block diagram of unconstrained MPC}
            \label{fig:mpc_block}
        \end{figure}
      

\end{document}