\chapter{Robot Modelling}

The first step in controlling a robot is to understand its mathematical model.  
Every movement of a robot—at every tiny time step—is governed by its equations of motion.  
As a simple yet powerful example, let us consider a \textbf{two-wheel differential drive robot}.


\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.8]{../diagrams/robot/robot-differential_drive.png}
    \caption{Differential drive robot geometry and notation.}
    \label{fig:differential_drive_robot}
\end{figure}

Figure~\ref{fig:differential_drive_robot} shows a schematic of such a robot.  
The center of the robot is denoted by $O$, and the distance between the two driving wheels is $L$ [m].  
Each wheel produces a linear velocity, denoted $v_l$ and $v_r$ [m/s] for the left and right wheel respectively.  
If the wheels are rotating with angular velocities $\omega_l$ and $\omega_r$ [rad/s],  
then the corresponding linear velocities can be expressed as

\[
v_l = \omega_l r, \quad v_r = \omega_r r,
\]
where $r$ [m] is the wheel radius.

In practical robotics, motor speed is often measured in revolutions per minute (rpm).  
The relationship between angular velocity in radians per second and rpm is given by

\[
\omega = rpm \cdot \frac{2\pi}{60}.
\]

Knowing the individual wheel velocities, we can express the \textbf{robot's linear velocity} $v$ as the average of both wheels:

\[
v = \frac{1}{2}(v_l + v_r).
\]

The corresponding \textbf{linear displacement} $d$ [m] evolves over time as

\[
\frac{d d}{d t} = v.
\]

Similarly, the \textbf{robot's angular rate} $\omega$ [rad/s] and \textbf{orientation angle} $\theta$ [rad] are related by

\[
\omega = \frac{v_r - v_l}{L}, \quad \frac{d\theta}{dt} = \omega.
\]

These two variables — linear and angular velocities — fully describe the planar motion of a differential drive robot.


\textbf{Control Inputs}

In practice, the control inputs to the robot are the individual motor commands,  
denoted $u_{\text{left}}$ and $u_{\text{right}}$.  
However, it is often more convenient to work with combined control variables:
the \textbf{linear velocity command} $u_v$ and the \textbf{angular velocity command} $u_{\omega}$, defined as

\begin{align}
u_{\text{left}}  &= u_v - u_{\omega}, \nonumber \\
u_{\text{right}} &= u_v + u_{\omega}.
\end{align}

This formulation allows independent control of forward motion and rotation,  
which greatly simplifies controller design and enables linear control strategies.



\textbf{Instantaneous Center of Rotation (ICR)}

In the diagram, point $C$ represents the \textbf{instantaneous center of rotation (ICR)}.  
This point lies on the axis connecting the two wheels,  
and its distance from the robot’s center $O$ depends on the ratio between left and right wheel velocities.

The distance $D$ from $O$ to the ICR is given by

\[
D = \frac{L}{2} \cdot \frac{v_l + v_r}{v_r - v_l}.
\]

When both wheels move at the same speed ($v_l = v_r$), the denominator becomes zero,  
and thus $D \to \infty$ — which corresponds to straight-line motion.



\subsection{Motion Formalism}

The \textbf{state-space model} is commonly used to describe how a robot's trajectory evolves over time.  
A physical system can be represented by a continuous-time state-space model, where the state is expressed as $x(t)$.  
However, for our purposes — particularly for controller implementation in digital systems — a \textbf{discrete-time model} is more convenient, denoted as $x(n)$.


For a very simple case, such as a slowly moving robot with negligible inertia, the state can be represented using only two quantities:  
the \textbf{linear displacement} $d$ [m] and the \textbf{orientation angle} $\theta$ [rad]:

\begin{align}
    x(n) &= 
    \begin{bmatrix} 
        d(n) \\[4pt] 
        \theta(n)
    \end{bmatrix}.
\end{align}

However, a real robot — especially one that moves quickly or has non-negligible inertia — cannot be accurately modeled in this minimal form.  
When the motors are turned off, the robot does not stop instantaneously due to its momentum.  
To capture this physical behavior, we extend the state vector by including the \textbf{robot's linear velocity} $v$ [m/s]  
and the \textbf{robot's angular rate} $\omega$ [rad/s], leading to the following definition:

\begin{align}
    x(n) &= 
    \begin{bmatrix} 
        d(n) \\[4pt] 
        \theta(n) \\[4pt] 
        v(n) \\[4pt] 
        \omega(n)
    \end{bmatrix}.
\end{align}


In a similar way, we define the \textbf{control input vector} $u(n)$ as:

\begin{align}
    u(n) &= 
    \begin{bmatrix} 
        u_v(n) \\[4pt] 
        u_{\omega}(n)
    \end{bmatrix},
    \label{eq:robot_input}
\end{align}

where $u_v$ and $u_{\omega}$ represent the commanded linear and angular control inputs, respectively.  
In this book, we assume that

\begin{align}
    \textcolor{red}{u \text{ is unit-less, in the range } \langle -1, 1 \rangle,}
\end{align}

meaning that these commands are normalized.  
They can later be mapped to real-world actuator quantities — for example, motor RPM, PWM duty cycle, or desired wheel velocity — depending on the specific hardware configuration.

Let us now describe the relationship between the robot's state $x$ and control input $u$,  
starting with a simplified (inertia-free) model that does not include velocity terms:

\begin{align}
    d(n+1) &= d(n) + b_0 \, u_v(n), \nonumber \\
    \theta(n+1) &= \theta(n) + b_1 \, u_{\omega}(n).
    \label{eq:simple_dynamics}
\end{align}

These two equations are completely independent:  
the first describes how the robot's position changes,  
while the second describes how its orientation evolves.  
The constant $b_0$ expresses how strongly the linear control $u_v$ affects forward motion —  
it depends on motor speed, wheel diameter, and control step length.  
Similarly, $b_1$ expresses how efficiently the robot turns —  
it depends on the same motor characteristics and the wheelbase $L$.  

\textbf{Higher motor speed or larger wheel radius} increases $b_0$,  
while a \textbf{larger wheelbase} decreases $b_1$ because the robot must rotate more slowly for the same wheel speed difference.


\textbf{Practical estimation of $b_0$ and $b_1$:}

If we know the maximum wheel speed at full control input $u = 1$, denoted $RPM_{\text{max}}$,  
and the wheel radius $r$ [m], along with the control sampling period $\Delta T$ [s],  
we can estimate the corresponding maximum linear and angular velocities as:

\begin{align}
    v_{\text{max}} &= 2\pi \frac{RPM_{\text{max}} \, r}{60}, \nonumber \\[4pt]
    \omega_{\text{max}} &= 4\pi \frac{RPM_{\text{max}} \, r}{60L}.
    \label{eq:v_omega_params_est}
\end{align}

From these relations, we can approximate the discrete-time model parameters as:

\begin{align}
    b_0 &= v_{\text{max}} \, \Delta T, \nonumber \\[4pt]
    b_1 &= \omega_{\text{max}} \, \Delta T.
    \label{eq:b_params_est}
\end{align}

This allows us to estimate a simple, inertia-free model directly from basic geometric parameters and motor specifications.  
Although this model is only approximate, it works well for low-speed motion or when a rough dynamic approximation is sufficient.


\textbf{Matrix form of the state-space model:}

In conventional control theory, the discrete-time state-space model is expressed compactly as:

\begin{align}
    x(n+1) = A x(n) + B u(n).
\end{align}

Rewriting the simplified dynamics from Eq.~\ref{eq:simple_dynamics} in this formalism yields:

\begin{align}   
    \begin{bmatrix} 
        d(n+1) \\[4pt] 
        \theta(n+1)
    \end{bmatrix} &=
    \underbrace{\begin{bmatrix} 
        1 & 0\\[4pt] 
        0 & 1
    \end{bmatrix}}_{A}
    \begin{bmatrix} 
        d(n) \\[4pt] 
        \theta(n)
    \end{bmatrix}
    +
    \underbrace{\begin{bmatrix} 
        b_0 & 0 \\[4pt] 
        0   & b_1
    \end{bmatrix}}_{B}
    \begin{bmatrix} 
        u_v(n) \\[4pt] 
        u_{\omega}(n)
    \end{bmatrix}.
\end{align}


\textbf{Commentary:}

This simple kinematic model forms the foundation of robot motion control.  
Although it ignores acceleration dynamics, wheel slip, and mechanical delays,  
it is extremely useful for initial controller design, algorithm prototyping, and understanding how inputs affect motion.  
In later chapters, we will extend this formulation to include velocity dynamics, actuator limitations, and state estimation,  
which together lead to more realistic and robust control architectures.
The more details how state space models works can be found in chapter the \textbf{Capturing dynamics}.




\subsection{Creating a Simulator}

We start by implementing a robot class that handles the robot dynamics.  
The implementation is intentionally simple, using the \textbf{NumPy} library for matrix operations.  
This choice allows us to later describe more complex dynamics (e.g., with inertia or slip effects)  
without changing the underlying mathematical framework.

The constructor of the \textbf{class DifferentialDriveModel} is defined as:

\begin{lstlisting}[style=python_style]
def __init__(self, b0, b1, width, height)
\end{lstlisting}

This constructor receives the parameters describing robot dynamics ($b_0$, $b_1$)  
and the robot’s physical dimensions (\texttt{width}, \texttt{height}), useful for visualization purposes.

By calling:

\begin{lstlisting}[style=python_style]
def reset(self, initial_x, initial_y, initial_theta)
\end{lstlisting}

we can reset the robot’s state vector and bring it to the desired initial position and orientation.

The main function, which is called repeatedly in the simulation loop, is:

\begin{lstlisting}[style=python_style]
def step(self, u)
\end{lstlisting}

It accepts a control input vector $u$ and returns the current state dictionary:

\begin{lstlisting}[style=python_style]
self.robot_state = {}
self.robot_state["width"]  = self.width
self.robot_state["height"] = self.height

self.robot_state["x"]     = self.x
self.robot_state["x_pos"] = self.x_pos
self.robot_state["y_pos"] = self.y_pos
self.robot_state["theta"] = theta
\end{lstlisting}

---

The remaining question is:  
\textbf{How do we convert the internal robot state $(d, \theta)$ into Cartesian coordinates $(x_{pos}, y_{pos})$?}

The robot’s state space $(d, \theta)$ is convenient for control and dynamics modeling,  
but it does not directly tell us where the robot is located in the plane.  
We therefore need a geometric transformation.

At each discrete time step, the robot travels a distance increment:

\[
d_{pos}(n) = d(n+1) - d(n),
\]

and its current heading (orientation in the global frame) is $\theta(n)$.  
Thus, the displacement in Cartesian coordinates can be computed as:

\begin{align*}
    d_x(n) &= d_{pos}(n) \cos(\theta(n)), \\
    d_y(n) &= d_{pos}(n) \sin(\theta(n)).
\end{align*}

\textbf{Why this works:}  
The robot’s forward motion always occurs along its heading direction $\theta$.  
By decomposing the traveled distance $d_{pos}$ into its projections on the global $x$ and $y$ axes  
(using the cosine and sine of $\theta$), we obtain the actual movement in Cartesian space.  
This is a standard transformation between the robot’s local frame and the world frame.

Integrating (in discrete simulation simply summing) these increments gives the full global position:

\begin{align}
    d_{pos}(n) &= d(n+1) - d(n),         \nonumber \\
    d_x(n) &= d_{pos}(n) \cos(\theta(n)), \nonumber \\
    d_y(n) &= d_{pos}(n) \sin(\theta(n)), \nonumber \\
    x_{pos}(n+1) &= x_{pos}(n) + d_x(n),  \nonumber \\
    y_{pos}(n+1) &= y_{pos}(n) + d_y(n).  \label{eq:cartesian_update}
\end{align}

Here, $d$ and $\theta$ are taken from the robot state vector $x$.  
This approach lets us keep a simple linear state-space model for control purposes,  
while still maintaining accurate global position information for visualization, mapping, and collision detection.


\newpage
The complete Python implementation of the robot model is shown below:

\begin{lstlisting}[style=python_style]
import numpy

class DifferentialDriveModel:
    def __init__(self, b0, b1, width, height):
        self.A = numpy.array([[1, 0],
                              [0, 1]])
        self.B = numpy.array([[b0, 0],
                              [0, b1]])
        self.width  = width
        self.height = height

        self.reset(0, 0, 0)
        
    def reset(self, initial_x, initial_y, initial_theta):
        # Initialize state [d, theta]
        self.x = numpy.zeros((2, 1))
        self.x[1, 0] = initial_theta
        self.x_pos = initial_x
        self.y_pos = initial_y

        self.step(numpy.zeros((2, 1)))

    def step(self, u):
        # Discrete-time dynamics update
        x_new = self.A @ self.x + self.B @ u

        # Calculate position increment in Cartesian coordinates
        dpos  = x_new[0, 0] - self.x[0, 0]
        theta = self.x[1, 0]

        dx = dpos * numpy.cos(theta)
        dy = dpos * numpy.sin(theta)

        # Update global position
        self.x_pos += dx
        self.y_pos += dy

        # Update internal state
        self.x = numpy.array(x_new)

        # Fill result values
        self.robot_state = {
            "width":  self.width,
            "height": self.height,
            "x":      self.x,
            "x_pos":  self.x_pos,
            "y_pos":  self.y_pos,
            "theta":  theta
        }

        return self.robot_state
    
    def get_state(self):
        return self.robot_state
\end{lstlisting}

---

Every model must be tested.  
It is always good practice to choose \textbf{non-trivial parameters} to avoid errors that are hidden by “nice” numbers.  
Here we define robot dynamics, the simulation time step, motor parameters, and robot dimensions.

From the equations for maximum velocities (Eq.~\ref{eq:v_omega_params_est})  
and the parameter estimation (Eq.~\ref{eq:b_params_est}),  
we compute $b_0$ and $b_1$ and pass them into the robot model:

\begin{lstlisting}[style=python_style]
# Input parameters
dt      = 0.001         # time step [s]
r_wheel = 15.0 * 0.001  # wheel radius [m]
l_wheels= 95.0 * 0.001  # wheel separation [m]
rpm_max = 750           # maximum motor speed [RPM]

width   = 2 * l_wheels
height  = l_wheels

v_max = 2.0 * numpy.pi * rpm_max * r_wheel / 60.0
w_max = 4.0 * numpy.pi * rpm_max * r_wheel / (60.0 * l_wheels)

b0 = v_max * dt
b1 = w_max * dt   

# Initialize robot
robot = DifferentialDriveModel(b0, b1, width, height)
robot.reset(0, 0, 0)
\end{lstlisting}

---

Now, let the robot follow an \textbf{equilateral triangular trajectory}.  
This is a better test than a square path because 90-degree turns are a special case —  
they only affect one Cartesian coordinate at a time,  
while 120-degree turns give a more general motion pattern.

We define two possible control inputs:
\begin{itemize}
    \item Full-speed forward motion: $u = (1, 0)$
    \item In-place rotation: $u = (0, 1)$
\end{itemize}

To move along the triangle sides, we must compute how many simulation steps correspond to  
a 1-meter straight motion and a 120° turn (converted to radians):

\begin{lstlisting}[style=python_style]
n_steps_forward = round(1.0 / (v_max * dt))
angle = 120.0 * numpy.pi / 180.0
n_steps_turn = round(angle / (w_max * dt))
\end{lstlisting}

We now execute three segments of motion (forward 1 m, turn 120°) to complete the triangle,  
recording the robot’s positions for later plotting:

\begin{lstlisting}[style=python_style]
x_pos = []
y_pos = []

for j in range(3):
    # move robot for 1m distance
    for n in range(n_steps_forward):
        u = numpy.array([[1.0],[0.0]])

        state = robot.step(u)

        x_pos.append(state["x_pos"])
        y_pos.append(state["y_pos"])

    # turn robot at 120 degrees
    for n in range(n_steps_turn):
        u = numpy.array([[0.0],[1.0]])

        state = robot.step(u)

        x_pos.append(state["x_pos"])
        y_pos.append(state["y_pos"])

print("terminal state")
print("x_pos = ", round(state["x_pos"], 4))
print("y_pos = ", round(state["y_pos"], 4))
print("theta = ", round(state["theta"]*180.0/numpy.pi, 4))
\end{lstlisting}

At the end, the robot should return to approximately the same starting point,  
with its orientation close to zero (modulo $360^\circ$).  
In the test output, we observe:

\begin{lstlisting}[style=terminal_style]
terminal state
x_pos =  -0.0094
y_pos =   0.0167
theta =  356.6842
\end{lstlisting}

\textbf{Explanation:}  
This small offset from the starting position is caused by \textbf{numerical integration error} due to discretization.  
Because the simulation uses a finite time step $\Delta T = 1$ ms,  
the continuous motion is approximated by small discrete jumps.  
Such integration errors accumulate over time and cause the trajectory to drift slightly,  
especially in long simulations or when using small angular increments.

The resulting trajectory plot is shown in Figure~\ref{fig:triangular_trajectory_plot}.

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.5]{../images/plots/robot_simulation_test.png}
    \caption{Triangular trajectory plot}
    \label{fig:triangular_trajectory_plot}
\end{figure}

If we visualize the trajectory history (e.g., using OpenCV),  
we can see how the position gradually drifts — a natural effect of discrete simulation and rounding errors,  
as illustrated in Figure~\ref{fig:simulator_visualisation}.  
The complete implementation including visualization is available at:  
\href{https://github.com/michalnand/algorithms_for_mobile_robotics/blob/main/examples/robot_simulator_01/}{\texttt{examples/robot\_simulator\_01}}.

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.5]{../images/screenshots/simulator_test.png}
    \caption{Simulator visualization}
    \label{fig:simulator_visualisation}
\end{figure}

\textbf{Special cases of motion control}

It is useful to analyze how the robot behaves under specific control inputs.  
By assigning different values to the control vector $u = [u_v, u_\omega]^T$,  
we can immediately observe fundamental motion primitives that compose any possible trajectory:

\begin{itemize}
    \item \textbf{Straight-line motion:} $u = (1, 0)$ \\
    Both wheels receive identical input, hence they rotate at the same speed.  
    There is no angular component ($u_\omega = 0$), so the robot’s heading $\theta$ remains constant.  
    As a result, the robot moves in a straight line in the direction it currently faces.

    \item \textbf{In-place rotation:} $u = (0, 1)$ \\
    In this case, both wheels rotate in opposite directions with equal magnitude.  
    This creates a pure rotational motion around the robot’s center point, without any translation.  
    The linear velocity component is zero ($u_v = 0$), and the heading $\theta$ changes at a constant rate.

    \item \textbf{Circular motion:} $u = (1, 0.1)$ \\
    Here, both translational and rotational components are active.  
    The robot moves forward while simultaneously turning with a constant angular rate.  
    The resulting trajectory is a perfect circle, where the radius of the circle is given by:
    \[
        R = \frac{v}{\omega} = \frac{u_v \, v_{\text{max}}}{u_\omega \, \omega_{\text{max}}}.
    \]
    The larger the ratio $u_v/u_\omega$, the wider the circle.  
    When $u_\omega$ is small compared to $u_v$, the robot moves almost straight;  
    when $u_\omega$ is large, it spins tightly around a small radius.
\end{itemize}

This elegant behavior results from the \textbf{decoupled control formulation} in which  
the input vector $u$ directly represents the \emph{linear} and \emph{angular} control actions.  
Because the left and right motor signals are internally computed as:

\begin{align*}
    u_{\text{left}}  &= u_v - u_\omega, \\
    u_{\text{right}} &= u_v + u_\omega,
\end{align*}



the two control modes — translation and rotation — are cleanly separated.  
This makes both mathematical modeling and controller design straightforward,  
since any arbitrary trajectory can be expressed as a combination of linear motion and circular motion segments.

In fact, \textbf{the entire movement of a differential-drive robot is a continuous composition of these two basic primitives} —  
straight motion and circular arcs.  
This geometric interpretation is extremely valuable in higher-level path planning,  
as it allows complex paths to be represented using simple building blocks such as arcs and lines.

An example of such combined motion is shown in Figure~\ref{fig:simulator_visualisation_2},  
where the robot follows a smooth circular trajectory as a result of constant-speed turning.

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.5]{../images/screenshots/simulator_test_2.png}
    \caption{Simulator visualization of circular motion}
    \label{fig:simulator_visualisation_2}
\end{figure}


\newpage
\textbf{Summary:}  
In this section, we created a simple but complete simulation environment for a differential-drive robot.  
The reader learned how to:
\begin{itemize}
    \item Represent the robot dynamics in discrete state-space form.
    \item Transform robot motion from state variables $(d, \theta)$ into global Cartesian coordinates $(x, y)$.
    \item Implement and simulate the model in Python using NumPy.
    \item Test the model on a non-trivial trajectory and interpret integration errors.
\end{itemize}

Although the model ignores inertia and wheel slip,  
it provides a solid base for more advanced topics such as velocity control,  
model predictive control (MPC), and extended state estimation in later chapters.
